import ExcelJS from 'exceljs';
import fs from 'fs';
import path from 'path';
import PDFDocument from 'pdfkit';

// Dynamic imports to avoid module resolution issues
const config = require('../../../../config');
const models = require('../../models');
const ReportDataService = require('./ReportDataService');

// Destructure models
const { Report, ReportTemplate } = models;

// Define proper types for report data
type TableData = Record<string, any>[];
type ChartData = any;
type TextContent = string;

// Define section interface
interface ReportSection {
  title: string;
  type: string;
  dataKey: string;
}

type ReportData = {
  tables?: Record<string, TableData>;
  charts?: Record<string, ChartData>;
  text?: Record<string, TextContent>;
};

export class ReportGenerator {
  private dataService: any;

  constructor() {
    this.dataService = new ReportDataService.ReportDataService();
  }

  async generateReport(report: typeof Report, template: typeof ReportTemplate): Promise<string> {
    const data = await this.dataService.fetchReportData(report) as ReportData;

    switch (report.format) {
      case 'pdf':
        return this.generatePDFReport(report, template, data);
      case 'excel':
        return this.generateExcelReport(report, template, data);
      default:
        throw new Error(`Unsupported report format: ${report.format}`);
    }
  }

  private async generatePDFReport(
    report: typeof Report,
    template: typeof ReportTemplate,
    data: ReportData
  ): Promise<string> {
    const filePath = path.join(config.reports.outputPath, `${report.id}.pdf`);
    const doc = new PDFDocument();

    return new Promise((resolve, reject) => {
      const stream = fs.createWriteStream(filePath);

      // Header
      doc.fontSize(20).text(report.name, 50, 50);
      doc.fontSize(12).text(`Generated on: ${new Date().toLocaleString()}`, 50, 80);
      doc.moveDown();

      let currentY = 120;

      // Process sections
      template.sections.forEach((section: ReportSection) => {
        doc.fontSize(16).text(section.title, 50, currentY);
        currentY += 30;

        try {
          if (section.type === 'table' && data.tables?.[section.dataKey]) {
            const table = data.tables[section.dataKey];
            if (table && table.length > 0) {
              currentY = this.addTableToPDF(doc, table, currentY);
            }
          } else if (section.type === 'chart' && data.charts?.[section.dataKey]) {
            doc.fontSize(12).text(`[Chart: ${section.title}]`, 50, currentY);
            currentY += 20;
          } else if (section.type === 'text' && data.text?.[section.dataKey]) {
            const textContent = data.text[section.dataKey]!;
            doc.fontSize(12).text(textContent, 50, currentY, {
              width: 500,
              align: 'left'
            });
            const textHeight = doc.heightOfString(textContent, { width: 500 });
            currentY += textHeight;
          }
        } catch (error) {
          console.error(`Error processing section '${section.title}':`, error);
          doc.fontSize(12).text(`[Error displaying ${section.title}]`, 50, currentY);
          currentY += 20;
        }

        currentY += 20; // Section spacing
      });

      // Footer
      const pageHeight = doc.page.height;
      doc.fontSize(10).text(
        `Page 1 of 1 | Generated by Compliance Platform`,
        50,
        pageHeight - 50
      );

      doc.pipe(stream);
      doc.end();
      stream.on('finish', () => resolve(filePath));
      stream.on('error', reject);
    });
  }

  private addTableToPDF(doc: any, table: TableData, yPosition: number): number {
    if (!table || !table.length) return yPosition;

    const headers = Object.keys(table[0] || {});
    const colWidth = 500 / headers.length;
    let currentY = yPosition;

    // Draw table headers
    headers.forEach((header, i) => {
      doc.font('Helvetica-Bold').text(header, 50 + i * colWidth, currentY);
    });
    currentY += 20;
    doc.font('Helvetica'); // Reset to regular font

    // Draw table rows
    table.forEach(row => {
      headers.forEach((header, i) => {
        const cellValue = row[header] ?? '';
        doc.text(String(cellValue), 50 + i * colWidth, currentY);
      });
      currentY += 20;
    });

    return currentY + 10; // Add extra spacing after table
  }

  private async generateExcelReport(
    report: typeof Report,
    template: typeof ReportTemplate,
    data: ReportData
  ): Promise<string> {
    const filePath = path.join(config.reports.outputPath, `${report.id}.xlsx`);
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Report');

    // Header
    worksheet.addRow([report.name]);
    worksheet.addRow([`Generated on: ${new Date().toLocaleString()}`]);
    worksheet.addRow([]);

    // Sections
    template.sections.forEach((section: ReportSection) => {
      const titleRow = worksheet.addRow([section.title]);
      titleRow.font = { bold: true };

      try {
        if (section.type === 'table' && data.tables?.[section.dataKey]) {
          const table = data.tables[section.dataKey];
          if (table && table.length > 0) {
            const headers = Object.keys(table[0] || {});

            // Add headers
            const headerRow = worksheet.addRow(headers);
            headerRow.font = { bold: true };

            // Add rows
            table.forEach(row => {
              const rowData = headers.map(header => row[header] ?? '');
              worksheet.addRow(rowData);
            });
          }
        } else if (section.type === 'text' && data.text?.[section.dataKey]) {
          worksheet.addRow([data.text[section.dataKey]]);
        }
      } catch (error) {
        console.error(`Error processing section '${section.title}':`, error);
        worksheet.addRow([`[Error displaying ${section.title}]`]);
      }

      worksheet.addRow([]); // Empty row for spacing
    });

    await workbook.xlsx.writeFile(filePath);
    return filePath;
  }
}
